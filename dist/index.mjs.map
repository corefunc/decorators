{"version":3,"file":"index.mjs","sources":["../src/method/attempt.mjs","../src/method/console-group.mjs","../src/method/measure-execution.mjs"],"sourcesContent":["/**\n * @name attempt\n * @namespace method\n * @param {Function} handlerFunction Function to handle error, accepts one argument - actual error\n * @returns {Function}\n * @example\n * ```javascript\n * class Kitty {\n *   @attempt((error: Error, args: any[]) => {\n *     console.warn(\"Exception thrown!\");\n *     console.log(error.message); // \"uwu\"\n *     console.dir(args); // [ 10, false ]\n *   })\n *   meow(volume: number, cute = true) {\n *     throw new Error(\"uwu\");\n *   }\n * }\n * new Kitty().meow(10, false);\n * ```\n * @since 0.0.1\n */\nexport function attempt(handlerFunction) {\n  return function attemptDecorator(_target, _key, descriptor) {\n    const originalMethod = descriptor.value;\n    if (Object.prototype.toString.call(originalMethod) === \"[object AsyncFunction]\") {\n      descriptor.value = async function (...args) {\n        try {\n          const value = await originalMethod.apply(this, args);\n          if (value !== undefined && value.catch) {\n            value.catch((error) => handlerFunction(error, args));\n          }\n          return value;\n        } catch (error) {\n          handlerFunction(error, args);\n        }\n      };\n    } else {\n      descriptor.value = function (...args) {\n        try {\n          return originalMethod.apply(this, args);\n        } catch (error) {\n          handlerFunction(error, args);\n        }\n      };\n    }\n  };\n}\n","/**\n * @name consoleGroup\n * @namespace method\n * @param {string} label Decorates method with inline group in the Web Console log.\n * @returns {Function}\n * @example\n * ```javascript\n * class Class {\n *   @consoleGroup(\"GROUP ASYNC\")\n *   async asyncRun() {\n *     console.log(\"I'm async\");\n *   }\n *   @consoleGroup(\"GROUP SYNC\")\n *   syncRun() {\n *     console.log(\"I'm sync\");\n *   }\n * }\n * const test = new Class();\n * test.syncRun();\n * await test.asyncRun();\n * @since 0.0.3\n */\nexport function consoleGroup(label) {\n  return function consoleGroupDecorator(_target, _key, descriptor) {\n    const originalMethod = descriptor.value;\n    if (Object.prototype.toString.call(originalMethod) === \"[object AsyncFunction]\") {\n      descriptor.value = async function (...args) {\n        console.group(label);\n        try {\n          const value = await originalMethod.apply(this, args);\n          console.groupEnd();\n          return value;\n        } catch (error) {\n          console.groupEnd();\n          throw error;\n        }\n      };\n    } else {\n      descriptor.value = function (...args) {\n        console.group(label);\n        try {\n          const value = originalMethod.apply(this, args);\n          console.groupEnd();\n          return value;\n        } catch (error) {\n          console.groupEnd();\n        }\n      };\n    }\n    return descriptor;\n  };\n}\n","/**\n * @name measureExecution\n * @namespace method\n * @param {string} label Measure method execution using `console.time()`\n * @returns {Function}\n * @example\n * ```javascript\n * class Class {\n *   @measureExecution(\"long execution time\")\n *   hardTask() {\n *     let result = 0;\n *     for (let index = 0; index < 1_000_000_000; index++) {\n *       result += index;\n *     }\n *     return result;\n *   }\n * }\n * new Class().hardTask();\n * ```\n * @since 0.0.2\n */\nexport function measureExecution(label) {\n  return function measureExecutionDecorator(_target, _key, descriptor) {\n    const originalMethod = descriptor.value;\n    if (Object.prototype.toString.call(originalMethod) === \"[object AsyncFunction]\") {\n      descriptor.value = async function (...args) {\n        console.time(label);\n        try {\n          const value = await originalMethod.apply(this, args);\n          console.timeEnd(label);\n          return value;\n        } catch (error) {\n          console.timeEnd(label);\n          throw error;\n        }\n      };\n    } else {\n      descriptor.value = function (...args) {\n        console.time(label);\n        try {\n          const value = originalMethod.apply(this, args);\n          console.timeEnd(label);\n          return value;\n        } catch (error) {\n          console.timeEnd(label);\n          throw error;\n        }\n      };\n    }\n    return descriptor;\n  };\n}\n"],"names":["attempt","handlerFunction","attemptDecorator","_target","_key","descriptor","originalMethod","value","Object","prototype","toString","call","async","args","apply","this","undefined","catch","error","consoleGroup","label","consoleGroupDecorator","console","group","groupEnd","measureExecution","measureExecutionDecorator","time","timeEnd"],"mappings":"AAqBO,SAASA,QAAQC,UACf,SAASC,iBAAiBC,EAASC,EAAMC,SACxCC,EAAiBD,EAAWE,MACqB,2BAAnDC,OAAOC,UAAUC,SAASC,KAAKL,GACjCD,EAAWE,MAAQK,kBAAmBC,aAE5BN,QAAcD,EAAeQ,MAAMC,KAAMF,eACjCG,IAAVT,GAAuBA,EAAMU,OAC/BV,EAAMU,MAAOC,GAAUjB,EAAgBiB,EAAOL,IAEzCN,EACP,MAAOW,GACPjB,EAAgBiB,EAAOL,KAI3BR,EAAWE,MAAQ,YAAaM,cAErBP,EAAeQ,MAAMC,KAAMF,GAClC,MAAOK,GACPjB,EAAgBiB,EAAOL,MCnB1B,SAASM,aAAaC,UACpB,SAASC,sBAAsBlB,EAASC,EAAMC,SAC7CC,EAAiBD,EAAWE,YACqB,2BAAnDC,OAAOC,UAAUC,SAASC,KAAKL,GACjCD,EAAWE,MAAQK,kBAAmBC,GACpCS,QAAQC,MAAMH,aAENb,QAAcD,EAAeQ,MAAMC,KAAMF,UAC/CS,QAAQE,WACDjB,EACP,MAAOW,SACPI,QAAQE,WACFN,IAIVb,EAAWE,MAAQ,YAAaM,GAC9BS,QAAQC,MAAMH,aAENb,EAAQD,EAAeQ,MAAMC,KAAMF,UACzCS,QAAQE,WACDjB,EACP,MAAOW,GACPI,QAAQE,aAIPnB,GC5BJ,SAASoB,iBAAiBL,UACxB,SAASM,0BAA0BvB,EAASC,EAAMC,SACjDC,EAAiBD,EAAWE,YACqB,2BAAnDC,OAAOC,UAAUC,SAASC,KAAKL,GACjCD,EAAWE,MAAQK,kBAAmBC,GACpCS,QAAQK,KAAKP,aAELb,QAAcD,EAAeQ,MAAMC,KAAMF,UAC/CS,QAAQM,QAAQR,GACTb,EACP,MAAOW,SACPI,QAAQM,QAAQR,GACVF,IAIVb,EAAWE,MAAQ,YAAaM,GAC9BS,QAAQK,KAAKP,aAELb,EAAQD,EAAeQ,MAAMC,KAAMF,UACzCS,QAAQM,QAAQR,GACTb,EACP,MAAOW,SACPI,QAAQM,QAAQR,GACVF,IAILb"}